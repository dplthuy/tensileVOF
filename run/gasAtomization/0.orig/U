/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2106                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       volVectorField;
    object      U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
#include "./initialConditions"

dimensions      [0 1 -1 0 0 0 0];

internalField   uniform (0 0 0);

boundaryField
{
    gasInlet
    {
        type		 pressureDirectedInletVelocity;
		inletDirection	 #codeStream
		{
		codeOptions
		#{
			-I$(LIB_SRC)/finiteVolume/lnInclude \
			-I$(LIB_SRC)/meshTools/lnInclude
		#};
		
		codeLibs
		#{
			-lmeshTools \
			-lfiniteVolume
		#};
		
		codeInclude
		#{
			#include "fvCFD.H"
			#include <cmath>
			#include <iostream>
		#};
		
		code
		#{
			const IOdictionary& d = static_cast<const IOdictionary&>
			(
				dict.parent().parent()
			);
			
			const fvMesh& mesh = refCast<const fvMesh>(d.db());
			const label id = mesh.boundary().findPatchID("gasInlet");
			const fvPatch& patch = mesh.boundary()[id];

			vectorField direction = patch.Sf();
			
			const scalar pi = constant::mathematical::pi;
			const scalar theta = 73.0*pi/180; // Angle of the gas inlet in radians
			
			const scalar nZ = -sin(theta);
			const scalar nXY = -cos(theta);
			const vector xNormal(1, 0, 0);
			
			forAll(direction, i)
			{
				vector coord = patch.Cf()[i];
				coord[2] = 0;
				scalar cosPhi = (xNormal & coord) / (mag(xNormal)*mag(coord));
				scalar phi = acos(cosPhi);

				scalar nX = cosPhi * nXY;
				scalar nY = 0;

				if (coord[1] > 0)
				{
					nY = sin(phi) * nXY;	
				}
				else if (coord[1] < 0)
				{
					nY = -sin(phi) * nXY;	
				}
							
						
				direction[i] = vector(nX, nY, nZ);
			}
			
			direction.writeEntry("",os);
		
		#};
		};
		value		uniform (0 0 0);
    }
    meltInlet
    {
    	type				flowRateInletVelocity;
		volumetricFlowRate	$meltFlowRate;
		extrapolateProfile	no;
		value				uniform (0 0 0);
    }
    cylinder
    {
		type		pressureInletOutletVelocity;
		phi			phi;
		rho			rho;
		tangentialVelocity	uniform (0 0 0);
		value		uniform (0 0 0);
    }
    outlet
    {
    	type		pressureInletOutletVelocity;
		phi			phi;
		rho			rho;
		tangentialVelocity	uniform (0 0 0);
		value		uniform (0 0 0);
    }
    symmetry1
    {
        type        symmetry;
    }
    symmetry2
    {
        type        symmetry;
    }
    nozzleWalls
    {
	    type		noSlip;
    }

}


// ************************************************************************* //
